GETTER
	Hay algun control sobre el tamanyo de los value en t_envl?
	Por ejemplo el path deberia ser como maximo 1024  => MAX_PATH en nuestras macros

EXPANDER
    $$ -> PID
    $var
    $(var)
    $((var or expresion))
        cómo interpreta los caracteres dentro de una expresión
            son tratados como integres que se convierten a cero?
            son tratados como un is_digit?
    NOTA:
    En caso de que no se cierra una comilla esa línea completa queda excluida del parser

    EXPANDIR $$
        ESTE COMANDO EN UNA FUNCIÓN PODRÍA OBTENER EL PID EN UN FILE SIN TENER LA FUNCION getpid() QUE NO ESTA PERMITIDA
        ps aux | grep minishell | awk '{print $2}' | head -n 1 > FILE
        DESPUES ABRIR EL FILE Y OBTENER EL STRING
        IMPRIMIRLO
        BORRAR EL FILE CON rm FILE
    ${variable:-valor_por_defecto}
    ${variable:+valor_por_defecto}

    ~:dir del usuario /home
    $*:todos los parámetros ?? QUE ES ESTO
    $2:segundo parámetro ?? QUE ES ESTO
    $0:nombre del script ?? QUE ES ESTO
    $?:código de salida OK
    $/:número de parámetros ?? QUE ES ESTO
    $!:pid del último trabajo en segundo plano ?? QUE ES ESTO

    $((expresión)) - NOT HADLED
    $[expresión] - NOT HANDLED
    + - / * % , < <= > >= == != , && || !
    :precedencia de operadores, paréntesis para alterar la precedencia
    :variables dentro de la expresión
    :funciones matemáticas dentro de la expresión

    ${variables/espresión/reemplazo}
    *:cualquier string
    ?:cualquier char


ENV
VIGILAR EL SHELL LEVEL
	void	ft_shlvl(t_env **env, t_env *temp, int shlvl, char *str)
{
	temp = *env;
	while (temp)
	{
		if (ft_strncmp(temp->key, "SHLVL", 5) == 0)
		{
			shlvl = ft_atoi(temp->value);
			if (shlvl > 999)
			{
				str = ft_itoa(shlvl + 1);
				ft_putstr_fd("minishell: warning: shell level (", 2);
				ft_putstr_fd(str, 2);
				ft_putstr_fd(") too high, resetting to 1\n", 2);
				shlvl = 0;
				free(str);
			}
			if (shlvl < 0)
				shlvl = -1;
			shlvl++;
			free(temp->value);
			temp->value = ft_itoa(shlvl);
			break ;
		}
		temp = temp->next;
	}
}

Proteccion de SHLV 0 a 999

-----

Cuando se exporta $NADA=algo
debería dar que =algo no es bueno,
pero está tomando como export sin argumentos
$NADA == '\n' hay que mirarlo con que no tenga nada después, porque si lo tiene hay que redirigir a error con argumento => &comando[1]



en errors_start se puede poner validacione s de syntax
